## 1-1

从最简单的的hello.c开始，我们可以使用gcc -o hello hello.c,分为四个阶段，预处理，编译，汇编，链接

1. 预处理(pre-processor)
预处理命令就是'#'包含的,包括有宏等,经过预处理,hello.c就变为了hello.i文件。\
移除注释。\
处理宏定义。\
处理条件编译指令（例如 #ifdef、#ifndef）。\
展开头文件（#include）
2. 编译(compiler)
hello.i文件经过编译之后会生成hello.s(汇编文件).

3. 汇编(assemble)
将上一步的hello.s编译为hello.o文件,这是一个可重定向的文件

4. 链接(link)
将我们hello.c文件中的printf.o文件与hello.o文件合并,最终生成我们想要的结果\

牢记这四步的发生!

## 1-2

顺便回顾一下gcc命令选项,默认什么都不加的话是生成a.out

```shell
# 这个意思是我不想要叫做a.out名字的程序,我把这个起了个我想要的名字 myFile
gcc -o myFile hello.c

#只编译源文件而不进行链接,有些东西在编译的时候是没问题的,链接就会有问题,这个会生成.o文件
gcc -c hello.c

#编译时可生成调试信息
gcc -g hello.c

#还有就是编译标准,就是使用c11标准来编译源文件

gcc -std=c11 hello.c
```

个人认为这就是比较有用的命令.

## 1-3

程序计数器(pc),program counter。实际上就是一个rs,里面存储着下一条命令的地址，当结束当前命令的时候，计数器会跳到下一条要执行的命令地方，进而使程序执行下去。
内存四区中不太熟悉的两个区

1. 代码区
    
在代码区中，顾名思义，存放的是编译后的机器代码，这些代码通常只是可读的，不支持修改。

2. 数据区

也叫做全局区，存放的是全局变量和静态变量，包括已经初始化的全局变量和未经初始化的全局变量，特点是在程序开始时就分配好内存，一直存在，直到程序截至,其中,未经初始化的全局变量在初始时一般会被赋值为0

## 1-4

1. 抽象的概念
2. 加速比
阿姆达尔定律,指的是加速效率,比如,我们想要把某个程序在不改变原来算法的情况下把源程序的速度提高5倍,这时,我们就可以通过这个公式来考虑\
假设原来的运行时间为 $T_{old}$,这里还有一个概念是加速因子 $a$,这个的意思是说,可加速部分的时间是$aT_{old}$,所以不可加速的部分是$T_{old}-aT_{old}$,假设经过加速的加速因子速度为 $K$,可加速部分就是$\frac{a}{K}T_{old}$,不可加速部分时间就是$(1-a)T_{old}$,所以加速后总程序时间就是这两部分和 $\frac{a}{K}T_{old}+(1-a)T_{old}$
所以前后的时间之比为
$$\frac{T_{old}}{\frac{a}{K}T_{old}+(1-a)T_{old}}$$
进行约分,发现结果为
$$\frac{1}{\frac{a}{K}+(1-a)}$$
假设$a=0.6,K=3$,计算得加速比是$1.67$,考虑一种极限情况,当加速因子趋于无穷大时,也就是我们把这$0.6$,也就是把这百分之60加速到几乎不花时间,我们发现程序最多也能到 $\frac{1}{1-a}$ 我们发现加速时间比取决于可加速的部分$a$,当$a$可加速部分越多,时间也就快

## 2-1

1. 信息的存储
   字节存储
   一个字节是8位(bits),然后就是字节序的概念,这里分为大端存储和小段存储\
   大端存储:高位在内存的低地址处,低位在内存的高地址处\
   小段存储:低位在内存低地址处,高位在内存高地址处.
   考虑一个数0x87654321,一个很自然的想法,和在十进制里面一样,从右向左是低位数字到高位数字,那么考虑地址,我们假设有一块地址是0x01,0x02,0x03,0x04,正好够储存一个32位的数字,根据小端序,这段数字在内存里面的存储方式就是:|21|43|65|87|,正好是反着读的,而在大端序里面就是
   |87|65|43|21|
   ps:现在绝大多数机器都是小端序存储.

2. 字符串存储
   c语言的字符串是以'\0'结尾
   位运算与16进制表示方法
   突然想起来RISC-V里面的的一个小练习:有一个数0x87654321,我先要得到高四位数字即,0x8765,和低四位0x4321,这里就用到了一个位运算 $&$操作,可以让0x87654321与上0xffff0000,然后再进行右移操作,同理得到低四位可以让0x87654321与上0x0000ffff,那么就可以得到低四位.
   然后就是逻辑右移和算数右移,左移都是一样的,在后面补0就可以了,右移的话,如果是算数右移,那么有符号数就要考虑符号位的情况了,如果符号位是1,那么算数右移后前面也应该补上1,对于无符号数来说补0就可以.

## 2-2

1. 有符号数和无符号数\
比较有趣的是$0xff$这个数其实在表示的时候是个-1,这是对于有符号数,对于无符号数来说,这个就是无符号数的最大值,其次,我们还可以根据下面(2)中的补码视角来看这个数,对于这个数来说,最高位就是$-2^8=-256$,后面那七位都是正的,和就是


2. 补码新的计算方式，实际上计算负数的补码时，不仅可以通过源码按位取反，反码加1来的到补码，反而还可以使用二进制的直接概念，把符号位的那个1来当做负数来参加运算，比如，-10的原码是$11010$,那么他的反码就是$10101$(注意,按位取反的时候符号位不用取反),那么他的补码就是$10110$
我们可以来看一眼这个数代表多少,按照以往的方法,那么还得先减1然后再取反的到原码,然后根据原码来确定这个数是多少,现在,我们可以直接使用一个小技巧,把第一位那个1当作负数去参加运算,就是$-2^4+2^2+2^1=-16+4=2=-10$,直接就可以看出来是-10

3. 位运算小技巧
   如何得到一个数的负数
    1. 按位取反再加1,对于一个x, $-x=~x+1$
    2. lowbit,得到一个数的二进制的最右边那个1,比如1个数$0101 0110$,最右边那个1就是$0000 0010$,可以用$x&-x$,也是$x&(~x+1)$
4. 课堂测验

对于一个有符号数$x,y$,下面结论是否正确

$x<0\Rightarrow x*2<0$\
$ux>=0$\
$(x与7)==7\Rightarrow((x<<30)<0)$\
$ux>-1$\
$x>y \Rightarrow -x<-y$\
$x*x>=0$\
$x>0 and y>0\Rightarrow x+y>0$\
$x>=0\Rightarrow -x<=0$\
$x<=0\Rightarrow -x>=0$\
$(x|-x)>>31 \Rightarrow 结果为-1$

第一个不对,可能会溢出为正数,第二个是无符号数,第三个正确,第四个不对,-1是最大的无符号数,第五个也不对,假设y是最小的有符号数,即$10000 0000$,按照之前的取相反数的技巧,按位取反+1,按位取反是$01111 1111$,加上1后还是$10000 0000$,所以这个是不对的,六七都是有可能溢出,第八个$x>=0\Rightarrow -x<=0$这个是正确的,因为按照之前的数最大的数就是$01111 1111$按照之前的技巧就是$10000 0000+1$我们发现这个不会溢出,所以这个是正确的,第九个同理,最后一个,我们发现根据补码规则x|-x的第一位,如果x不是0的话,那么最高位为1,那么右移是算数右移,最高位是1,右移31位后那么就是$1111 1111$就是-1,但是对0来说不成立

