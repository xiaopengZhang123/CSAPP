## 1-1

从最简单的的hello.c开始，我们可以使用gcc -o hello hello.c,分为四个阶段，预处理，编译，汇编，链接

1. 预处理(pre-processor)
预处理命令就是'#'包含的,包括有宏等,经过预处理,hello.c就变为了hello.i文件。\
移除注释。\
处理宏定义。\
处理条件编译指令（例如 #ifdef、#ifndef）。\
展开头文件（#include）
2. 编译(compiler)
hello.i文件经过编译之后会生成hello.s(汇编文件).

3. 汇编(assemble)
将上一步的hello.s编译为hello.o文件,这是一个可重定向的文件

4. 链接(link)
将我们hello.c文件中的printf.o文件与hello.o文件合并,最终生成我们想要的结果\

牢记这四步的发生!

## 1-2

顺便回顾一下gcc命令选项,默认什么都不加的话是生成a.out

```shell
# 这个意思是我不想要叫做a.out名字的程序,我把这个起了个我想要的名字 myFile
gcc -o myFile hello.c

#只编译源文件而不进行链接,有些东西在编译的时候是没问题的,链接就会有问题,这个会生成.o文件
gcc -c hello.c

#编译时可生成调试信息
gcc -g hello.c

#还有就是编译标准,就是使用c11标准来编译源文件

gcc -std=c11 hello.c
```

个人认为这就是比较有用的命令.

## 1-3

程序计数器(pc),program counter。实际上就是一个rs,里面存储着下一条命令的地址，当结束当前命令的时候，计数器会跳到下一条要执行的命令地方，进而使程序执行下去。
内存四区中不太熟悉的两个区

1. 代码区
    
在代码区中，顾名思义，存放的是编译后的机器代码，这些代码通常只是可读的，不支持修改。

2. 数据区

也叫做全局区，存放的是全局变量和静态变量，包括已经初始化的全局变量和未经初始化的全局变量，特点是在程序开始时就分配好内存，一直存在，直到程序截至,其中,未经初始化的全局变量在初始时一般会被赋值为0

## 1-4

1. 抽象的概念
2. 加速比
阿姆达尔定律,指的是加速效率,比如,我们想要把某个程序在不改变原来算法的情况下把源程序的速度提高5倍,这时,我们就可以通过这个公式来考虑\
假设原来的运行时间为 $T_{old}$,这里还有一个概念是加速因子 $a$,这个的意思是说,可加速部分的时间是$aT_{old}$,所以不可加速的部分是$T_{old}-aT_{old}$,假设经过加速的加速因子速度为 $K$,可加速部分就是$\frac{a}{K}T_{old}$,不可加速部分时间就是$(1-a)T_{old}$,所以加速后总程序时间就是这两部分和 $\frac{a}{K}T_{old}+(1-a)T_{old}$
所以前后的时间之比为
$$\frac{T_{old}}{\frac{a}{K}T_{old}+(1-a)T_{old}}$$
进行约分,发现结果为
$$\frac{1}{\frac{a}{K}+(1-a)}$$
假设$a=0.6,K=3$,计算得加速比是$1.67$,考虑一种极限情况,当加速因子趋于无穷大时,也就是我们把这$0.6$,也就是把这百分之60加速到几乎不花时间,我们发现程序最多也能到 $\frac{1}{1-a}$ 我们发现加速时间比取决于可加速的部分$a$,当$a$可加速部分越多,时间也就快

## 2-1

1. 信息的存储
   字节存储
   一个字节是8位(bits),然后就是字节序的概念,这里分为大端存储和小段存储\
   大端存储:高位在内存的低地址处,低位在内存的高地址处\
   小段存储:低位在内存低地址处,高位在内存高地址处.
   考虑一个数0x87654321,一个很自然的想法,和在十进制里面一样,从右向左是低位数字到高位数字,那么考虑地址,我们假设有一块地址是0x01,0x02,0x03,0x04,正好够储存一个32位的数字,根据小端序,这段数字在内存里面的存储方式就是:|21|43|65|87|,正好是反着读的,而在大端序里面就是
   |87|65|43|21|
   

